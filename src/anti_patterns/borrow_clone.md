# Клонирование для удовлетворения borrow checker

## Описание

Borrow checker предотвращает Rust-пользователей от разработки небезопасного кода, гарантируя, что либо: существует только одна изменяемая ссылка, либо много неизменяемых ссылок. Если написанный код не соответствует этим условиям, этот анти-паттерн возникает, когда разработчик решает проблему компилятора, клонируя переменную.

## Пример

```rust
// define any variable
let mut x = 5;

// Borrow `x` -- but clone it first
let y = &mut (x.clone());

// without the x.clone() two lines prior, this line would fail on compile as
// x has been borrowed
// thanks to x.clone(), x was never borrowed, and this line will run.
println!("{}", x);

// perform some action on the borrow to prevent rust from optimizing this
//out of existence
*y += 1;
```

## Мотивация

Этот шаблон часто используется, особенно для начинающих, чтобы решить проблемы с borrow checker. Однако это имеет серьезные последствия. Использование `.clone()` приводит к созданию копии данных. Любые изменения между ними не синхронизируются - как если бы существовали две полностью отдельные переменные.

Есть особые случаи - `Rc<T>` предназначен для интеллектуальной обработки клонов. Он внутренне управляет ровно одной копией данных, и клонирование его приведет только к клонированию ссылки.

Также есть `Arc<T>`, который обеспечивает общую собственность значения типа T, выделенного в куче. Вызов `.clone()` на `Arc` создает новый экземпляр `Arc`, который указывает на ту же выделение в куче, что и исходный `Arc`, увеличивая счетчик ссылок.

В целом, клонирование должно быть обдуманным, с полным пониманием последствий. Если клон используется для того, чтобы сделать ошибку borrow checker исчезнуть, это хороший признак того, что этот анти-паттерн может быть использован.

Несмотря на то, что `.clone()` является признаком плохого шаблона, иногда **нормально писать неэффективный код**, в случаях, когда:

- разработчик все еще новичок в владении
- код не имеет больших ограничений на скорость или память
  (например, хакатонные проекты или прототипы)
- удовлетворение borrow checker действительно сложно, и вы предпочитаете
  оптимизировать читабельность в ущерб производительности

Если подозревается, что клон не нужен, необходимо полностью понимать главу [Ownership](https://doc.rust-lang.org/book/ownership.html) книги Rust, прежде чем оценивать, нужен ли клон или нет.

Также обязательно запускайте `cargo clippy` в своем проекте, который обнаруживает некоторые
случаи, когда `.clone()` не нужен, например, [1](https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone),
[2](https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy),
[3](https://rust-lang.github.io/rust-clippy/master/index.html#map_clone) или [4](https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref).

## Смотрите также

- [`mem::{take(_), replace(_)}` для сохранения владеемых значений в измененных перечислениях](../idioms/mem-replace.md)
- [Документация `Rc<T>`, который обрабатывает `.clone()` интеллектуально](http://doc.rust-lang.org/std/rc/)
- [Документация `Arc<T>`, потокобезопасный указатель с подсчетом ссылок](https://doc.rust-lang.org/std/sync/struct.Arc.html)
- [Хитрости с владением в Rust](https://web.archive.org/web/20210120233744/https://xion.io/post/code/rust-borrowchk-tricks.html)
