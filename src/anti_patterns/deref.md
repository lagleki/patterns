# `Deref` полиморфизм

## Описание

Использование трейта `Deref` для эмуляции наследования между структурами и, таким образом, повторного использования методов.

## Пример

Иногда мы хотим эмулировать следующий общий паттерн из ОО-языков, таких как Java:

```java
class Foo {
    void m() { ... }
}

class Bar extends Foo {}

public static void main(String[] args) {
    Bar b = new Bar();
    b.m();
}
```

Мы можем использовать анти-паттерн полиморфизма deref для этого:

```rust
use std::ops::Deref;

struct Foo {}

impl Foo {
    fn m(&self) {
        //..
    }
}

struct Bar {
    f: Foo,
}

impl Deref for Bar {
    type Target = Foo;
    fn deref(&self) -> &Foo {
        &self.f
    }
}

fn main() {
    let b = Bar { f: Foo {} };
    b.m();
}
```

В Rust нет наследования структур. Вместо этого мы используем композицию и включаем экземпляр `Foo` в `Bar` (поскольку поле является значением, оно хранится встроенным, поэтому, если бы были поля, они бы имели ту же компоновку в памяти, что и версия Java (вероятно, вы должны использовать `#[repr(C)]`, если хотите быть уверены)).

Чтобы вызов метода работал, мы реализуем `Deref` для `Bar` с `Foo` в качестве цели (возвращая встроенное поле `Foo`). Это означает, что когда мы разыменовываем `Bar` (например, используя `*`), мы получим `Foo`. Это довольно странно. Разыменование обычно дает `T` из ссылки на `T`, здесь у нас два несвязанных типа. Однако, поскольку оператор точки выполняет неявное разыменование, это означает, что вызов метода будет искать методы на `Foo`, а также на `Bar`.

## Преимущества

Вы экономите немного паттерна, например,

```rust,ignore
impl Bar {
    fn m(&self) {
        self.f.m()
    }
}
```

## Недостатки

Прежде всего, это удивительный идиоматический оборот - будущие программисты, читающие это в коде, не будут ожидать, что это произойдет. Это потому, что мы злоупотребляем трейтом `Deref`, а не используем его, как предполагалось (и документировалось и т. д.). Это также связано с тем, что механизм здесь полностью неявный.

Этот паттерн не вводит подтипизацию между `Foo` и `Bar`, как наследование в Java или C++, не автоматически реализованные для `Bar`, поэтому этот паттерн плохо взаимодействует с проверкой границ и, следовательно, с обобщенным программированием.

Использование этого паттерна дает существенно отличающуюся семантику от большинства ОО-языков в отношении `self`. Обычно он остается ссылкой на подкласс, с этим паттерном он будет «классом», где определен метод.

Наконец, этот паттерн поддерживает только одиночное наследование и не имеет понятия интерфейсов, наследуемой конфиденциальности на основе классов или других функций, связанных с наследованием. Таким образом, он дает опыт, который будет существенно отличаться для программистов, привыкших к наследованию Java и т. д.

## Обсуждение

Нет одного хорошего альтернативного варианта. В зависимости от конкретных обстоятельств может быть лучше переопределить с использованием трейтов или написать методы фасада для ручной диспетчеризации в `Foo`. Мы намерены добавить механизм наследования, аналогичный этому, в Rust, но, вероятно, это займет некоторое время, прежде чем он достигнет стабильной версии Rust. См. эти [блог](http://aturon.github.io/blog/2015/09/18/reuse/) [посты](http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/) и этот [RFC issue](https://github.com/rust-lang/rfcs/issues/349) для получения дополнительной информации.

Трейт `Deref` предназначен для реализации пользовательских типов указателей. Намерение заключается в том, что он будет принимать указатель на `T` к `T`, а не преобразовывать между различными типами. Жаль, что это не (вероятно, не может быть) обеспечено определением трейта.

Rust пытается найти баланс между явными и неявными механизмами, отдавая предпочтение явным преобразованиям между типами. Автоматическое разыменование в операторе точки - это случай, когда эргономика сильно выигрывает за счет неявного механизма, но намерение заключается в том, что это ограничено степенями косвенности, а не преобразованием между произвольными типами.

## Смотрите также

- [Коллекции - идиоматические умные указатели](../idioms/deref.md).
- Крейты делегирования для уменьшения паттерна, такие как [delegate](https://crates.io/crates/delegate)
  или [ambassador](https://crates.io/crates/ambassador)
- [Документация для трейта `Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html).
