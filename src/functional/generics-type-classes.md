# Обобщения как классы типов

## Описание

Система типов Rust разработана больше как функциональные языки (например, Haskell), а не как императивные языки (например, Java и C++). В результате Rust может превратить многие виды проблем программирования в проблемы "статической типизации". Это одна из самых больших побед выбора функционального языка и критически важна для многих гарантий времени компиляции Rust.

Ключевая часть этой идеи - это то, как работают обобщенные типы. В C++ и Java, например, обобщенные типы являются метапрограммным конструктом для компилятора. `vector<int>` и `vector<char>` в C++ - это просто две разные копии одного и того же шаблонного кода для типа `vector` (известного как `template`) с двумя разными заполненными типами.

В Rust параметр обобщенного типа создает то, что в функциональных языках известно как "ограничение класса типов", и каждый разный параметр, заполненный конечным пользователем, _фактически изменяет тип_. Другими словами, `Vec<isize>` и `Vec<char>` _являются двумя разными типами_, которые признаются как разные всеми частями системы типов.

Это называется **мономорфизацией**, где из **полиморфного** кода создаются разные типы. Это особое поведение требует `impl` блоков для указания обобщенных параметров. Разные значения для обобщенного типа вызывают разные типы, и разные типы могут иметь разные блоки `impl`.

В объектно-ориентированных языках классы могут наследовать поведение от своих родителей. Однако это позволяет прикреплять не только дополнительное поведение к конкретным членам класса типов, но и дополнительное поведение.

Ближайший эквивалент - это полиморфизм времени выполнения в Javascript и Python, где новые члены могут быть добавлены в объекты наугад любым конструктором. Однако, в отличие от этих языков, все дополнительные методы Rust могут быть проверены на типы во время использования, потому что их обобщенные типы статически определены. Это делает их более удобными при сохранении безопасности.

## Пример

Предположим, вы разрабатываете сервер хранения для серии лабораторных машин. Из-за используемого программного обеспечения вам нужно поддерживать два разных протокола: BOOTP (для сетевой загрузки PXE) и NFS (для удаленного монтирования хранилища).

Ваша цель - иметь одну программу, написанную на Rust, которая может обрабатывать оба протокола. Он будет иметь обработчики протоколов и слушать оба типа запросов. Затем основная логика приложения позволит администратору лаборатории настраивать хранение и контроль безопасности для фактических файлов.

Запросы от машин в лаборатории на файлы содержат ту же базовую информацию, независимо от того, из какого протокола они пришли: метод аутентификации и имя файла для получения. Простая реализация будет выглядеть примерно так:

```rust,ignore
enum AuthInfo {
    Nfs(crate::nfs::AuthInfo),
    Bootp(crate::bootp::AuthInfo),
}

struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
}
```

Такой дизайн может работать достаточно хорошо. Но теперь предположим, что вам нужно поддерживать добавление метаданных, которые _специфичны для протокола_. Например, с NFS вы хотели бы определить, какая точка монтирования у них есть, чтобы применять дополнительные правила безопасности.

Текущая структура оставляет решение о протоколе до времени выполнения. Это означает, что любой метод, который применяется к одному протоколу и не к другому, требует от программиста проверки времени выполнения.

Вот как будет выглядеть получение точки монтирования NFS:

```rust,ignore
struct FileDownloadRequest {
    file_name: PathBuf,
    authentication: AuthInfo,
    mount_point: Option<PathBuf>,
}

impl FileDownloadRequest {
    // ... other methods ...

    /// Gets an NFS mount point if this is an NFS request. Otherwise,
    /// return None.
    pub fn mount_point(&self) -> Option<&Path> {
        self.mount_point.as_ref()
    }
}
```

Каждый вызывающий `mount_point()` должен проверять на `None` и писать код для его обработки. Это верно даже если они знают, что только запросы NFS когда-либо используются в данном пути кода!

Было бы гораздо более оптимально вызвать ошибку времени компиляции, если разные типы запросов были перепутаны. В конце концов, весь путь кода пользователя, включая то, какие функции из библиотеки они используют, будет знать, является ли запрос запросом NFS или запросом BOOTP.

В Rust это действительно возможно! Решение заключается в _добавлении обобщенного типа_ для разделения API.

Вот как это выглядит:

```rust
use std::path::{Path, PathBuf};

mod nfs {
    #[derive(Clone)]
    pub(crate) struct AuthInfo(String); // NFS session management omitted
}

mod bootp {
    pub(crate) struct AuthInfo(); // no authentication in bootp
}

// private module, lest outside users invent their own protocol kinds!
mod proto_trait {
    use std::path::{Path, PathBuf};
    use super::{bootp, nfs};

    pub(crate) trait ProtoKind {
        type AuthInfo;
        fn auth_info(&self) -> Self::AuthInfo;
    }

    pub struct Nfs {
        auth: nfs::AuthInfo,
        mount_point: PathBuf,
    }

    impl Nfs {
        pub(crate) fn mount_point(&self) -> &Path {
            &self.mount_point
        }
    }

    impl ProtoKind for Nfs {
        type AuthInfo = nfs::AuthInfo;
        fn auth_info(&self) -> Self::AuthInfo {
            self.auth.clone()
        }
    }

    pub struct Bootp(); // no additional metadata

    impl ProtoKind for Bootp {
        type AuthInfo = bootp::AuthInfo;
        fn auth_info(&self) -> Self::AuthInfo {
            bootp::AuthInfo()
        }
    }
}

use proto_trait::ProtoKind; // keep internal to prevent impls
pub use proto_trait::{Nfs, Bootp}; // re-export so callers can see them

struct FileDownloadRequest<P: ProtoKind> {
    file_name: PathBuf,
    protocol: P,
}

// all common API parts go into a generic impl block
impl<P: ProtoKind> FileDownloadRequest<P> {
    fn file_path(&self) -> &Path {
        &self.file_name
    }

    fn auth_info(&self) -> P::AuthInfo {
        self.protocol.auth_info()
    }
}

// all protocol-specific impls go into their own block
impl FileDownloadRequest<Nfs> {
    fn mount_point(&self) -> &Path {
        self.protocol.mount_point()
    }
}

fn main() {
    // your code here
}
```

С таким подходом, если пользователь допустит ошибку и использует неправильный тип;

```rust,ignore
fn main() {
    let mut socket = crate::bootp::listen()?;
    while let Some(request) = socket.next_request()? {
        match request.mount_point().as_ref()
            "/secure" => socket.send("Access denied"),
            _ => {} // continue on...
        }
        // Rest of the code here
    }
}
```

Они получат синтаксическую ошибку. Тип `FileDownloadRequest<Bootp>` не реализует `mount_point()`, только тип `FileDownloadRequest<Nfs>`. И это создается модулем NFS, а не модулем BOOTP, конечно!

## Преимущества

Во-первых, это позволяет дедуплицировать поля, которые общие для нескольких состояний. Необщие поля реализуются один раз, сделав их обобщенными.

Во-вторых, это делает блоки `impl` более читаемыми, потому что они разбиты по состояниям. Методы, общие для всех состояний, набираются один раз в одном блоке, а методы, уникальные для одного состояния, находятся в отдельном блоке.

Оба этих фактора означают, что кода меньше, и он лучше организован.

## Недостатки

В настоящее время это увеличивает размер двоичного файла из-за того, как мономорфизация реализована в компиляторе. Надеемся, что реализация сможет улучшиться в будущем.

## Альтернативы

- Если тип кажется нуждающимся в "разделенном API" из-за конструкции или частичной инициализации, рассмотрите [шаблон Строитель](../patterns/creational/builder.
