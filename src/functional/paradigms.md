# Парадигмы программирования

Одно из самых больших препятствий для понимания функциональных программ при переходе от императивного подхода - это изменение мышления. Императивные программы описывают **как** что-то сделать, тогда как декларативные программы описывают **что** сделать. Давайте сложим числа от 1 до 10, чтобы показать это.

## Императивный подход

```rust
let mut sum = 0;
for i in 1..11 {
    sum += i;
}
println!("{}", sum);
```

С императивными программами нам приходится играть в компилятор, чтобы понять, что происходит. Здесь мы начинаем с `sum` равным `0`. Затем мы проходим через диапазон от 1 до 10. Каждый раз в цикле мы добавляем соответствующее значение в диапазоне. Затем мы выводим это.

| `i` | `sum` |
| :-: | :---: |
|  1  |   1   |
|  2  |   3   |
|  3  |   6   |
|  4  |  10   |
|  5  |  15   |
|  6  |  21   |
|  7  |  28   |
|  8  |  36   |
|  9  |  45   |
| 10  |  55   |

Так мы начинаем программировать. Мы учимся, что программа - это набор шагов.

## Декларативный подход

```rust
println!("{}", (1..11).fold(0, |a, b| a + b));
```

Вау! Это действительно по-другому! Что здесь происходит?
Помните, что с декларативными программами мы описываем **что** делать, а не **как** это делать. `fold` - это функция, которая [компонует](https://en.wikipedia.org/wiki/Function_composition) функции. Название является соглашением из Haskell.

Здесь мы компонуем функции сложения (это замыкание: `|a, b| a + b`) с диапазоном от 1 до 10. `0` - это начальная точка, поэтому `a` вначале равно `0`. `b` - это первый элемент диапазона, `1`. `0 + 1 = 1` - это результат. Так что теперь мы снова `fold`, с `a = 1`, `b = 2`, и так далее, пока не дойдем до последнего элемента в диапазоне, `10`.

| `a` | `b` | result |
| :-: | :-: | :----: |
|  0  |  1  |   1    |
|  1  |  2  |   3    |
|  3  |  3  |   6    |
|  6  |  4  |   10   |
| 10  |  5  |   15   |
|  15 |  6  |   21   |
|  21 |  7  |   28   |
|  28 |  8  |   36   |
|  36 |  9  |   45   |
|  45 | 10  |   55   |
```
