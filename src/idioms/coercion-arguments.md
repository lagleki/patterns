# Используйте заимствованные типы для аргументов

## Описание

Использование цели косвенного приведения типов может увеличить гибкость вашего кода, когда вы решаете, какой тип аргумента использовать для функции. Таким образом, функция будет принимать больше типов ввода.

Это не ограничивается типами, которые можно нарезать или толстыми указателями. Фактически, вы всегда должны предпочитать использовать **заимствованный тип** вместо **заимствования владеющего типа**. Например, `&str` вместо `&String`, `&[T]` вместо `&Vec<T>` или `&T` вместо `&Box<T>`.

Используя заимствованные типы, вы можете избежать слоев косвенности для тех случаев, когда владеющий тип уже обеспечивает слой косвенности. Например, у `String` есть слой косвенности, поэтому у `&String` будет два слоя косвенности. Мы можем избежать этого, используя вместо этого `&str` и позволяя `&String` приводиться к `&str` при вызове функции.

## Пример

Для этого примера мы проиллюстрируем некоторые различия при использовании `&String` в качестве аргумента функции по сравнению с использованием `&str`, но идеи также применимы к использованию `&Vec<T>` вместо использования `&[T]` или использованию `&Box<T>` вместо `&T`.

Рассмотрим пример, где мы хотим определить, содержит ли слово три подряд гласных. Нам не нужно владеть строкой, чтобы определить это, поэтому мы возьмем ссылку.

Код может выглядеть примерно так:

```rust
fn three_vowels(word: &String) -> bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' => {
                vowel_count += 1;
                if vowel_count >= 3 {
                    return true
                }
            }
            _ => vowel_count = 0
        }
    }
    false
}

fn main() {
    let ferris = "Ferris".to_string();
    let curious = "Curious".to_string();
    println!("{}: {}", ferris, three_vowels(&ferris));
    println!("{}: {}", curious, three_vowels(&curious));

    // This works fine, but the following two lines would fail:
    // println!("Ferris: {}", three_vowels("Ferris"));
    // println!("Curious: {}", three_vowels("Curious"));

}
```

Это работает нормально, потому что мы передаем тип `&String` в качестве параметра. Если мы уберем комментарии в последних двух строках, пример не будет работать. Это происходит потому, что тип `&str` не приводится к типу `&String`. Мы можем исправить это, просто изменяя тип нашего аргумента.

Например, если мы изменяем объявление нашей функции на:

```rust, ignore
fn three_vowels(word: &str) -> bool {
```

то обе версии будут компилироваться и выводить одинаковый результат.

```bash
Ferris: false
Curious: true
```

Но это еще не все! В этой истории есть еще что-то. Вероятно, вы можете сказать себе: это не имеет значения, я все равно никогда не буду использовать `&'static str` в качестве ввода (как мы сделали, когда использовали `"Ferris"`). Даже игнорируя этот специальный пример, вы все равно можете обнаружить, что использование `&str` даст вам больше гибкости, чем использование `&String`.

Давайте теперь рассмотрим пример, где кто-то дает нам предложение, и мы хотим определить, содержит ли какое-либо из слов в предложении три подряд гласных. Мы, вероятно, должны использовать функцию, которую мы уже определили, и просто подавать каждое слово из предложения.

Пример может выглядеть так:

```rust
fn three_vowels(word: &str) -> bool {
    let mut vowel_count = 0;
    for c in word.chars() {
        match c {
            'a' | 'e' | 'i' | 'o' | 'u' => {
                vowel_count += 1;
                if vowel_count >= 3 {
                    return true
                }
            }
            _ => vowel_count = 0
        }
    }
    false
}

fn main() {
    let sentence_string =
        "Once upon a time, there was a friendly curious crab named Ferris".to_string();
    for word in sentence_string.split(' ') {
        if three_vowels(word) {
            println!("{} has three consecutive vowels!", word);
        }
    }
}
```

Запуск этого примера с использованием нашей функции, объявленной с типом аргумента `&str`, даст

```bash
curious has three consecutive vowels!
```

Однако этот пример не будет работать, когда наша функция объявлена с типом аргумента `&String`. Это происходит потому, что срезы строк - это `&str`, а не `&String`, который требует выделения памяти для преобразования в `&String`, что неявно, в то время как преобразование из `String` в `&str` дешево и неявно.

## Смотрите также

- [Справочник языка Rust по приведению типов](https://doc.rust-lang.org/reference/type-coercions.html)
- Для более подробного обсуждения того, как обрабатывать `String` и `&str`, см.
  [эту серию блогов (2015)](https://web.archive.org/web/20201112023149/https://hermanradtke.com/2015/05/03/string-vs-str-in-rust-functions.html)
  от Herman J. Radtke III