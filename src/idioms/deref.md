# Коллекции - это умные указатели

## Описание

Используйте трейт [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html), чтобы обрабатывать коллекции как умные указатели, предоставляя владеющие и заимствованные представления данных.

## Пример

```rust,ignore
use std::ops::Deref;

struct Vec<T> {
    data: RawVec<T>,
    //..
}

impl<T> Deref for Vec<T> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        //..
    }
}
```

`Vec<T>` - это владеющая коллекция `T`, а срез (`&[T]`) - заимствованная коллекция `T`. Реализация `Deref` для `Vec` позволяет неявное разыменование от `&Vec<T>` до `&[T]` и включает отношение в автоматические поиски разыменования. Большинство методов, которые вы могли бы ожидать реализованными для `Vec`, вместо этого реализованы для срезов.

Также `String` и `&str` имеют аналогичное отношение.

## Мотивация

Владение и заимствование - это ключевые аспекты языка Rust. Структуры данных должны правильно учитывать эти семантики, чтобы обеспечить хороший пользовательский опыт. При реализации структуры данных, которая владеет своими данными, предоставление заимствованного представления этих данных позволяет более гибким API.

## Преимущества

Большинство методов могут быть реализованы только для заимствованного представления, они затем неявно доступны для владеющего представления.

Дает клиентам выбор между заимствованием или владением данных.

## Недостатки

Методы и трейты, доступные только через разыменование, не учитываются при проверке границ, поэтому обобщенное программирование со структурами данных, использующими этот шаблон, может стать сложным (см. трейты `Borrow` и `AsRef` и т. д.).

## Обсуждение

Умные указатели и коллекции аналогичны: умный указатель указывает на один объект, тогда как коллекция указывает на множество объектов. С точки зрения системы типов, между ними мало различий. Коллекция владеет своими данными, если единственный способ доступа к каждому элементу - через коллекцию, и коллекция отвечает за удаление данных (даже в случае общего владения, некоторое заимствованное представление может быть уместным). Если коллекция владеет своими данными, обычно полезно предоставить представление данных как заимствованное, чтобы на него можно было ссылаться несколько раз.

Большинство умных указателей (например, `Foo<T>`) реализуют `Deref<Target=T>`. Однако коллекции обычно разыменовываются до пользовательского типа. `[T]` и `str` имеют некоторую поддержку языка, но в общем случае это не обязательно. `Foo<T>` может реализовать `Deref<Target=Bar<T>>`, где `Bar` - это тип с динамическим размером, а `&Bar<T>` - заимствованное представление данных в `Foo<T>`.

Обычно упорядоченные коллекции будут реализовывать `Index` для `Range`, чтобы предоставлять синтаксис среза. Целью будет заимствованное представление.

## Смотрите также

- [Антипаттерн полиморфизма разыменования](../anti_patterns/deref.md).
- [Документация для трейта `Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html).
