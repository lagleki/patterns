# Завершение в деструкторах

## Описание

Rust не предоставляет эквивалент блоков `finally` - кода, который будет выполнен
независимо от того, как функция завершается. Вместо этого деструктор объекта может
быть использован для выполнения кода, который должен быть выполнен перед выходом.

## Пример

```rust,ignore
fn bar() -> Result<(), ()> {
    // These don't need to be defined inside the function.
    struct Foo;

    // Implement a destructor for Foo.
    impl Drop for Foo {
        fn drop(&mut self) {
            println!("exit");
        }
    }

    // The dtor of _exit will run however the function `bar` is exited.
    let _exit = Foo;
    // Implicit return with `?` operator.
    baz()?;
    // Normal return.
    Ok(())
}
```

## Мотивация

Если функция имеет несколько точек возврата, то выполнение кода при выходе становится
сложным и повторяющимся (и, следовательно, склонным к ошибкам). Это особенно верно в случае,
когда возврат является неявным из-за макроса. Обычный случай - оператор `?`, который
возвращает, если результат является `Err`, но продолжает, если это `Ok`. `?` используется как
механизм обработки исключений, но в отличие от Java (которая имеет `finally`), нет
способа запланировать выполнение кода в обычных и исключительных случаях.
Паника также приведет к преждевременному выходу из функции.

## Преимущества

Код в деструкторах будет (почти) всегда выполняться - справляется с паниками, ранними
выходами и т.д.

## Недостатки

Не гарантируется, что деструкторы будут запущены. Например, если в функции есть бесконечный цикл
или если выполнение функции завершается аварийно до выхода. Деструкторы также не запускаются в случае
паники в уже паникующем потоке. Поэтому на деструкторы нельзя полагаться как на завершающие, где это
абсолютно необходимо.

Этот паттерн вводит некоторый неявный код, который трудно заметить. Чтение функции
не дает ясного указания на деструкторы, которые будут запущены при выходе. Это может сделать
отладку сложной.

Требование объекта и реализации `Drop` только для завершения является тяжеловесным.

## Обсуждение

Существует некоторая тонкость в том, как именно хранить объект, используемый в качестве
завершающего. Он должен быть сохранен до конца функции и затем уничтожен. Объект всегда должен быть
значением или уникальным владеющим указателем (например, `Box<Foo>`). Если используется общий указатель
(например, `Rc`), то завершающий объект может быть сохранен за пределами времени жизни функции. По
аналогичным причинам завершающий объект не должен быть перемещен или возвращен.

Завершающий объект должен быть присвоен переменной, иначе он будет уничтожен немедленно, а не при выходе
из области видимости. Имя переменной должно начинаться с `_`, если переменная используется только в качестве
завершающего объекта, в противном случае компилятор будет предупреждать, что завершающий объект не используется.
Однако не называйте переменную `_` без суффикса - в этом случае она будет уничтожена немедленно.

В Rust деструкторы запускаются, когда объект выходит из области видимости. Это происходит, независимо от того,
достигаем ли мы конца блока, есть ли ранний возврат или программа паникует. При панике Rust разворачивает стек,
запуская деструкторы для каждого объекта в каждом кадре стека. Таким образом, деструкторы вызываются даже если
паника происходит в вызываемой функции.

Если деструктор паникует во время разворачивания, нет хорошего действия, которое можно предпринять, поэтому Rust
немедленно прерывает поток, не запуская дополнительные деструкторы. Это означает, что деструкторы не абсолютно
гарантированы для запуска. Это также означает, что вы должны быть особенно осторожны в своих деструкторах, чтобы
не вызвать панику, поскольку это может оставить ресурсы в неожиданном состоянии.

## Смотрите также

[RAII guards](../patterns/behavioural/RAII.md).
