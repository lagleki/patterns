# `mem::{take(_), replace(_)}` для сохранения владеемых значений в измененных перечислениях

## Описание

Предположим, у нас есть `&mut MyEnum`, который имеет (как минимум) два варианта: `A { name: String, x: u8 }` и `B { name: String }`. Теперь мы хотим изменить `MyEnum::A` на `B`, если `x` равен нулю, сохраняя при этом `MyEnum::B`.

Мы можем сделать это без клонирования `name`.

## Пример

```rust
use std::mem;

enum MyEnum {
    A { name: String, x: u8 },
    B { name: String }
}

fn a_to_b(e: &mut MyEnum) {
    if let MyEnum::A { name, x: 0 } = e {
        // this takes out our `name` and put in an empty String instead
        // (note that empty strings don't allocate).
        // Then, construct the new enum variant (which will
        // be assigned to `*e`).
        *e = MyEnum::B { name: mem::take(name) }
    }
}
```

Это также работает с большим количеством вариантов:

```rust
use std::mem;

enum MultiVariateEnum {
    A { name: String },
    B { name: String },
    C,
    D
}

fn swizzle(e: &mut MultiVariateEnum) {
    use MultiVariateEnum::*;
    *e = match e {
        // Ownership rules do not allow taking `name` by value, but we cannot
        // take the value out of a mutable reference, unless we replace it:
        A { name } => B { name: mem::take(name) },
        B { name } => A { name: mem::take(name) },
        C => D,
        D => C
    }
}
```

## Мотивация

При работе с перечислениями мы можем захотеть изменить значение перечисления на месте, возможно, на другой вариант. Обычно это делается в два этапа, чтобы удовлетворить проверку заимствования. На первом этапе мы наблюдаем существующее значение и смотрим на его части, чтобы решить, что делать дальше. На втором этапе мы можем условно изменить значение (как в примере выше).

Проверка заимствования не позволит нам взять `name` из перечисления (потому что _что-то_ должно быть там). Мы могли бы, конечно, `.clone()` name и поместить клон в наш `MyEnum::B`, но это было бы примером анти-паттерна [Clone to satisfy the borrow checker](../anti_patterns/borrow_clone.md). В любом случае, мы можем избежать дополнительного выделения памяти, изменив `e` только с изменяемым заимствованием.

`mem::take` позволяет нам заменить значение, заменив его значением по умолчанию и возвращая предыдущее значение. Для `String` значение по умолчанию - это пустая `String`, которая не требует выделения памяти. В результате мы получаем исходное `name` _как владеемое значение_. Затем мы можем обернуть это в другое перечисление.

**ЗАМЕЧАНИЕ:** `mem::replace` очень похож, но позволяет нам указать, чем заменить значение. Эквивалентом нашей строки `mem::take` будет `mem::replace(name, String::new())`.

Однако следует отметить, что если мы используем `Option` и хотим заменить его значение на `None`, метод `take()` `Option` предоставляет более короткую и идиоматическую альтернативу.

## Преимущества

Смотрите, мама, без выделения памяти! Кроме того, вы можете почувствовать себя Индианой Джонсом, делая это.

## Недостатки

Это становится немного громоздким. Если вы несколько раз ошибетесь, вы начнете ненавидеть проверку заимствования. Компилятор может не суметь оптимизировать двойное хранение, что приведет к снижению производительности по сравнению с тем, что вы делали в небезопасных языках.

Кроме того, тип, который вы берете, должен реализовывать [`Default` trait](./default.md). Однако, если тип, с которым вы работаете, не реализует это, вы можете использовать `mem::replace`.

## Обсуждение

Этот паттерн интересен только в Rust. В языках с автоматическим управлением памятью вы по умолчанию берете ссылку на значение (и GC будет отслеживать ссылки), а в других низкоуровневых языках, таких как C, вы просто создаете псевдоним указателя и исправляете вещи позже.

Однако в Rust нам нужно сделать немного больше работы. Владеемое значение может иметь только одного владельца, поэтому, чтобы его извлечь, мы должны что-то вернуть - как Индиана Джонс, заменяя артефакт мешком с песком.

## Смотрите также

Это избавляет от анти-паттерна [Clone to satisfy the borrow checker](../anti_patterns/borrow_clone.md) в конкретном случае.
