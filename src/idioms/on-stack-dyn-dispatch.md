# Динамическая диспетчеризация на стеке

## Описание

Мы можем динамически диспетчеризовать несколько значений, однако для этого нам нужно
объявить несколько переменных для привязки объектов разных типов. Чтобы продлить
время жизни по мере необходимости, мы можем использовать отложенную условную инициализацию, как показано ниже:

## Пример

```rust
use std::io;
use std::fs;

# fn main() -> Result<(), Box<dyn std::error::Error>> {
# let arg = "-";

// These must live longer than `readable`, and thus are declared first:
let (mut stdin_read, mut file_read);

// We need to ascribe the type to get dynamic dispatch.
let readable: &mut dyn io::Read = if arg == "-" {
    stdin_read = io::stdin();
    &mut stdin_read
} else {
    file_read = fs::File::open(arg)?;
    &mut file_read
};

// Read from `readable` here.

# Ok(())
# }
```

## Мотивация

Rust мономорфизирует код по умолчанию. Это означает, что копия кода будет
сгенерирована для каждого типа, с которым он используется, и оптимизирована независимо. Хотя это
позволяет получить очень быстрый код на горячем пути, это также увеличивает размер кода в местах,
где производительность не является существенной, что стоит время компиляции и кэша.

К счастью, Rust позволяет нам использовать динамическую диспетчеризацию, но мы должны явно запросить ее.

## Преимущества

Нам не нужно выделять ничего на куче. Мы также не нуждаемся в инициализации чего-то, что мы не будем использовать позже, и не нужно мономорфизировать
весь код, который следует работать как с `File`, так и с `Stdin`.

## Недостатки

Код нуждается в большем количестве подвижных частей, чем версия на основе `Box`:

```rust,ignore
// We still need to ascribe the type for dynamic dispatch.
let readable: Box<dyn io::Read> = if arg == "-" {
    Box::new(io::stdin())
} else {
    Box::new(fs::File::open(arg)?)
};
// Read from `readable` here.
```

## Обсуждение

Новички в Rust обычно узнают, что Rust требует, чтобы все переменные были
инициализированы _перед использованием_, поэтому легко пропустить тот факт, что _неиспользуемые_
переменные могут быть неинициализированы. Rust работает довольно усердно, чтобы гарантировать, что это
работает хорошо и только инициализированные значения сбрасываются в конце их
области видимости.

Пример соответствует всем ограничениям, которые Rust накладывает на нас:

- Все переменные инициализируются перед использованием (в данном случае заимствованием) их
- Каждая переменная содержит только значения одного типа. В нашем примере `stdin` имеет
  тип `Stdin`, `file` имеет тип `File`, а `readable` имеет тип `&mut dyn Read`
- Каждое заимствованное значение превосходит все ссылки, заимствованные из него

## Смотрите также

- [Финализация в деструкторах](dtor-finally.md) и
  [RAII-стражи](../patterns/behavioural/RAII.md) могут получить выгоду от тесного контроля над
  временами жизни.
- Для условно заполненных `Option<&T>` (изменяемых) ссылок можно
  инициализировать `Option<T>` напрямую и использовать его метод [`.as_ref()`], чтобы получить
  необязательную ссылку.

[`.as_ref()`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.as_ref
