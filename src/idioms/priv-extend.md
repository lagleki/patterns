# `#[non_exhaustive]` и приватные поля для расширяемости

## Описание

Существует небольшой набор сценариев, когда автор библиотеки может захотеть добавить публичные поля в публичную структуру или новые варианты в перечисление, не нарушая обратной совместимости.

Rust предлагает два решения этой проблемы:

- Используйте `#[non_exhaustive]` на `struct`, `enum` и вариантах `enum`.
  Для подробной документации по всем местам, где `#[non_exhaustive]` может быть использован, см. [документацию](https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute).

- Вы можете добавить приватное поле в структуру, чтобы предотвратить его прямое создание или сопоставление (см. Альтернатива)

## Пример

```rust
mod a {
    // Public struct.
    #[non_exhaustive]
    pub struct S {
        pub foo: i32,
    }
    
    #[non_exhaustive]
    pub enum AdmitMoreVariants {
        VariantA,
        VariantB,
        #[non_exhaustive]
        VariantC { a: String }
    }
}

fn print_matched_variants(s: a::S) {
    // Because S is `#[non_exhaustive]`, it cannot be named here and
    // we must use `..` in the pattern.
    let a::S { foo: _, ..} = s;
    
    let some_enum = a::AdmitMoreVariants::VariantA;
    match some_enum {
        a::AdmitMoreVariants::VariantA => println!("it's an A"),
        a::AdmitMoreVariants::VariantB => println!("it's a b"),

        // .. required because this variant is non-exhaustive as well
        a::AdmitMoreVariants::VariantC { a, .. } => println!("it's a c"),

        // The wildcard match is required because more variants may be
        // added in the future
        _ => println!("it's a new variant")
    }
}
```

## Альтернатива: `Приватные поля` для структур

`#[non_exhaustive]` работает только через границы крейта.
Внутри крейта может использоваться метод приватного поля.

Добавление поля в структуру является в основном обратно совместимым изменением.
Однако, если клиент использует паттерн для деконструкции экземпляра структуры, он может назвать все поля в структуре, и добавление нового поля нарушит этот паттерн.
Клиент может назвать некоторые поля и использовать `..` в паттерне, в этом случае добавление
другого поля является обратно совместимым.
Сделав хотя бы одно из полей структуры приватным, вы заставите клиентов использовать последний
форму паттернов, обеспечивая, что struct будет готов к будущим изменениям.

Недостатком этого подхода является то, что вам может потребоваться добавить в структуру ненужное
поле.
Вы можете использовать тип `()` так, чтобы не было накладных расходов на время выполнения и добавить `_` в
имя поля, чтобы избежать предупреждения об неиспользуемом поле.

```rust
pub struct S {
    pub a: i32,
    // Because `b` is private, you cannot match on `S` without using `..` and `S`
    //  cannot be directly instantiated or matched against
    _b: ()
}
```

## Обсуждение

На `struct` `#[non_exhaustive]` позволяет добавлять дополнительные поля обратно
совместимым способом.
Он также предотвращает использование конструктора структуры клиентами, даже если все поля
являются публичными.
Это может быть полезно, но стоит обдумать, хотите ли вы, чтобы дополнительное поле
было найдено клиентами как ошибку компилятора, а не как что-то, что может быть тихо
необнаруженным.

`#[non_exhaustive]` также может быть применен к вариантам перечислений.
Вариант `#[non_exhaustive]` ведет себя так же, как и struct `#[non_exhaustive]`.

Используйте это сознательно и осторожно: увеличение основной версии при добавлении
полей или вариантов часто является лучшим вариантом.
`#[non_exhaustive]` может быть уместен в сценариях, где вы моделируете внешний
ресурс, который может изменяться несинхронно с вашей библиотекой, но это не
универсальный инструмент.

### Недостатки

`#[non_exhaustive]` может сделать ваш код гораздо менее эргономичным в использовании,
особенно когда вынуждены обрабатывать неизвестные варианты перечислений.
Он должен использоваться только тогда, когда эти типы эволюций требуются **без**
увеличения основной версии.

Когда `#[non_exhaustive]` применяется к `enum`, он заставляет клиентов обрабатывать
универсальный вариант.
Если в этом случае нет разумных действий, это может привести к неуклюжему
коду и путям кода, которые выполняются только в крайне редких случаях.
Если клиент решит `panic!()` в этом сценарии, было бы лучше выявить эту ошибку
на этапе компиляции.
Фактически, `#[non_exhaustive]` заставляет клиентов обрабатывать случай "Что-то еще";
в этом случае редко есть разумное действие.

## Смотрите также

- [RFC, вводящий атрибут #[non_exhaustive] для перечислений и структур](https://github.com/rust-lang/rfcs/blob/master/text/2008-non-exhaustive.md)
