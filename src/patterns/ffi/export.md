# Объектно-ориентированные API

## Описание

При проектировании API на Rust, которые будут использоваться на других языках, существуют некоторые важные принципы проектирования, которые противоречат обычному проектированию API на Rust:

1. Все инкапсулированные типы должны быть _владельцами_ Rust, _управляемыми_ пользователем и _непрозрачными_.
2. Все транзакционные типы данных должны быть _владельцами_ пользователем и _прозрачными_.
3. Вся библиотечная функциональность должна быть реализована в виде функций, действующих на инкапсулированные типы.
4. Вся библиотечная функциональность должна быть инкапсулирована в типах, не основанных на структуре, а на _происхождении/времени жизни_.

## Мотивация

Rust имеет встроенную поддержку FFI для других языков.
Он делает это, предоставляя способ авторам крейтов предоставлять совместимые с C API через различные ABI (хотя это не важно для этой практики).

Хорошо спроектированный Rust FFI следует принципам проектирования C API, минимизируя компромиссы в проектировании Rust. Существуют три цели любого внешнего API:

1. Сделать его легким в использовании на целевом языке.
2. Избежать диктата API внутренней небезопасности на стороне Rust насколько это возможно.
3. Сделать потенциал для небезопасности памяти и неопределенного поведения Rust как можно меньше.

Rust-код должен доверять безопасности памяти на языке программирования за пределами определенной точки. Однако каждый бит `unsafe`-кода на стороне Rust - это возможность для ошибок или усугубления `undefined behaviour`.

Например, если происхождение указателя неверно, это может привести к сегментации из-за недопустимого доступа к памяти. Но если он обрабатывается небезопасным кодом, это может привести к полноценной коррупции кучи.

Проектирование API на основе объектов позволяет писать оболочки, которые имеют хорошие характеристики безопасности памяти и четкую границу того, что является безопасным, а что - `unsafe`.

## Пример кода

Стандарт POSIX определяет API для доступа к базе данных в файле, известной как [DBM](https://web.archive.org/web/20210105035602/https://www.mankier.com/0p/ndbm.h).
Это отличный пример "объектно-ориентированного" API.

Вот определение на C, которое, надеюсь, должно быть легко прочитать для тех, кто занимается FFI. Комментарий ниже должен помочь объяснить его для тех, кто упускает тонкости.

```C
struct DBM;
typedef struct { void *dptr, size_t dsize } datum;

int     dbm_clearerr(DBM *);
void    dbm_close(DBM *);
int     dbm_delete(DBM *, datum);
int     dbm_error(DBM *);
datum   dbm_fetch(DBM *, datum);
datum   dbm_firstkey(DBM *);
datum   dbm_nextkey(DBM *);
DBM    *dbm_open(const char *, int, mode_t);
int     dbm_store(DBM *, datum, datum, int);
```

Этот API определяет два типа: `DBM` и `datum`.

Тип `DBM` был назван "инкапсулированным" типом выше.
Он предназначен для хранения внутреннего состояния и действует как точка входа для поведения библиотеки.

Он полностью непрозрачен для пользователя, который не может создать `DBM` самостоятельно, поскольку не знает его размера или структуры. Вместо этого он должен вызвать `dbm_open`, и это дает ему только _указатель на один_.

Это означает, что все `DBM` являются "владельцами" библиотеки в смысле Rust.
Внутреннее состояние неизвестного размера хранится в памяти, контролируемой библиотекой, а не пользователем. Пользователь может только управлять его жизненным циклом с помощью `open` и `close` и выполнять операции с ним с помощью других функций.

Тип `datum` был назван "транзакционным" типом выше.
Он предназначен для обмена информацией между библиотекой и ее пользователем.

База данных предназначена для хранения "неструктурированных данных" без предопределенной длины или значения. В результате `datum` является эквивалентом Rust-среза: набор байтов и количество их. Основное отличие заключается в том, что здесь нет информации о типе, что указывает `void`.

Имейте в виду, что этот заголовок написан с точки зрения библиотеки.
У пользователя, вероятно, есть какой-то тип, который он использует, и который имеет известный размер.
Но библиотеке все равно, и по правилам приведения типов C любой тип за указателем может быть приведен к `void`.

Как отмечалось ранее, этот тип _прозрачен_ для пользователя. Но также этот тип _владеется_ пользователем.
Это имеет тонкие последствия из-за указателя внутри него.
Вопрос в том, кто владеет памятью, на которую указывает этот указатель?

Ответ для лучшей безопасности памяти - "пользователь".
Но в случае, когда необходимо получить значение, пользователь не знает, как правильно его выделить (поскольку он не знает, какой длины это значение). В этом случае код библиотеки должен использовать кучу, к которой пользователь имеет доступ - такую ​​как библиотека C `malloc` и `free` - а затем _передать владение_ в смысле Rust.

Все это может показаться спекулятивным, н
