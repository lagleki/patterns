# Консолидация типов в обертки

## Описание

Этот паттерн предназначен для элегантной обработки нескольких связанных типов,
с минимизацией поверхности для небезопасности памяти.

Одним из угловых камней правил псевдонимов Rust являются времена жизни.
Это гарантирует, что многие паттерны доступа между типами могут быть безопасными для памяти,
включая безопасность гонок данных.

Однако, когда типы Rust экспортируются на другие языки, они обычно преобразуются
в указатели. В Rust указатель означает "пользователь управляет временем жизни указателя".
Это их ответственность избегать небезопасности памяти.

Таким образом, требуется некоторый уровень доверия в коде пользователя, особенно вокруг использования после освобождения,
что Rust не может ничего сделать. Однако некоторые конструкции API накладывают более высокие бремена
чем другие на написанный на другом языке код.

API с наименьшим риском - это "консолидированная обертка", где все возможные взаимодействия
с объектом сворачиваются в "обертку типа", при этом сохраняя чистый Rust API.

## Пример кода

Чтобы понять это, давайте рассмотрим классический пример экспортируемого API: итерацию
через коллекцию.

Этот API выглядит так:

1. Итератор инициализируется с помощью `first_key`.
2. Каждый вызов `next_key` продвигает итератор.
3. Вызовы `next_key`, если итератор находится в конце, ничего не делают.
4. Как указано выше, итератор "обернут" в коллекцию (в отличие от родного
   Rust API).

Если итератор эффективно реализует `nth()`, то возможно сделать его
эфемерным для каждого вызова функции:

```rust,ignore
struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
}

impl MySetWrapper {
    pub fn first_key(&mut self) -> Option<&Key> {
        self.iter_next = 0;
        self.next_key()
    }
    pub fn next_key(&mut self) -> Option<&Key> {
        if let Some(next) = self.myset.keys().nth(self.iter_next) {
            self.iter_next += 1;
            Some(next)
        } else {
            None
        }
    }
}
```

В результате обертка проста и не содержит кода `unsafe`.

## Преимущества

Это делает API более безопасным в использовании, избегая проблем с временами жизни между типами.
См. [API на основе объектов](./export.md) для получения дополнительной информации о преимуществах и недостатках,
избегаемых этим.

## Недостатки

Часто упаковка типов довольно сложна, и иногда компромисс Rust API сделал бы вещи проще.

В качестве примера рассмотрим итератор, который не эффективно реализует `nth()`.
Определенно стоило бы внести специальную логику, чтобы объект обрабатывал
итерацию внутри себя, или поддерживал другой эффективный способ доступа,
который будет использовать только API иностранной функции.

### Попытка упаковать итераторы (и неудача)

Чтобы правильно упаковать любой тип итератора в API, обертка должна была бы
делать то, что версия на C языке кода бы делала: стирать время жизни итератора,
и управлять им вручную.

Достаточно сказать, что это _невероятно_ сложно.

Вот иллюстрация только _одной_ проблемы.

Первая версия `MySetWrapper` будет выглядеть так:

```rust,ignore
struct MySetWrapper {
    myset: MySet,
    iter_next: usize,
    // created from a transmuted Box<KeysIter + 'self>
    iterator: Option<NonNull<KeysIter<'static>>>,
}
```

С использованием `transmute` для расширения времени жизни и указателя для его скрытия,
это уже уродливо. Но дело становится еще хуже: _любая другая операция может вызвать
неопределенное поведение Rust_.

Предположим, что `MySet` в обертке может быть изменен другими
функциями во время итерации, например, сохранение нового значения в ключ, по которому она
итерировалась. API не препятствует этому, и на самом деле некоторые аналогичные библиотеки на C языке ожидают этого.

Простая реализация `myset_store` будет такой:

```rust,ignore
pub mod unsafe_module {

    // other module content

    pub fn myset_store(
        myset: *mut MySetWrapper,
        key: datum,
        value: datum) -> libc::c_int {

        // DO NOT USE THIS CODE. IT IS UNSAFE TO DEMONSTRATE A PROLBEM.

        let myset: &mut MySet = unsafe { // SAFETY: whoops, UB occurs in here!
            &mut (*myset).myset
        };

        /* ...check and cast key and value data... */

        match myset.store(casted_key, casted_value) {
            Ok(_) => 0,
            Err(e) => e.into()
        }
    }
}
```

Если итератор существует, когда вызывается эта функция, мы нарушаем одно из правил псевдонимов Rust.
Согласно Rust, изменяемая ссылка в этом блоке должна иметь _исключительный_ доступ к объекту. Если итератор просто существует, это не исключительный доступ,
поэтому у нас есть `неопределенное поведение`! [^1]

Чтобы избежать этого, мы должны иметь способ гарантировать, что изменяемая ссылка действительно является исключительной.
Это в основном означает очистку общей ссылки итератора, пока она существует,
а затем ее восстановление. В большинстве случаев это все еще будет менее эффективно, чем
версия на C языке кода.

Некоторые могут спросить: как C может это сделать более эффективно?
Ответ - он обманывает. Правила псевдонимов Rust - это проблема, и C просто игнорирует
их для своих указателей. Взамен, часто можно увидеть код, который объявлен
вручную как "не потокобезопасный" в некоторых или всех обстоятельствах. На самом деле,
[GNU C библиотека](https://manpages.debian.org/buster/manpages/attributes.7.en.html)
имеет целый лексикон, посвященный параллельному поведению!

Rust предпочитает делать все безопасным для памяти все время, как для безопасности, так и для
оптимизаций, которые код на C не может достичь. Отказ от доступа к некоторым ярлыкам -
это цена, которую должны заплатить программисты Rust.

[^1]: Для программистов на C, которые скребут голову, итератор не должен
читаться _во время_ этого кода, вызывая UB. Правило исключительности также позволяет
оптимизациям компилятора, которые могут вызвать несогласованные наблюдения общей ссылки итератора (например, переполнение стека или перестановка инструкций для повышения эффективности).
Эти наблюдения могут происходить _в любое время после_ создания изменяемой ссылки.
